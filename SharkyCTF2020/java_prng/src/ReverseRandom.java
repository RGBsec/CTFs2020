// from https://stackoverflow.com/questions/15236151/inverse-function-of-javas-random-function

import java.util.Random;
import java.util.Arrays;

class RandomReverse {
    private static int[] genNum(long seed) {
        Random rand = new Random(seed);
        final int NUM_GEN = 10;
        int[] arr = new int[NUM_GEN];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = rand.nextInt();
        }

        return arr;
    }

    public static void main(String[] args) {
//        final long SEED = 782634283105L;
//        int[] arr = genNum(SEED);
//        System.out.println(Arrays.toString(arr));
//
//        Long result = reverse(arr);
//
//        if (result != null) {
//            System.out.println(Arrays.toString(genNum(result)));
//        } else {
//            System.out.println("Seed not found");
//        }
        int[] arr = {-583975528, 1737279113};
        System.out.println(Arrays.toString(genNum(reverse(arr))));
    }

    private static long combine(int rand, int suffix) {
        return (unsignedIntToLong(rand) << 16) | (suffix & ((1L << 16) - 1));
    }

    private static long unsignedIntToLong(int num) {
        return num & ((1L << 32) - 1);
    }

    // This function finds the seed of a sequence of integer,
    // generated by nextInt()
    // Can be easily modified to find the seed of a sequence
    // of long, generated by nextLong()
    private static Long reverse(int[] arr) {
        // Need at least 2 numbers.
        assert (arr.length > 1);

        int end = arr.length - 1;

        // Brute force lower 16 bits, then compare
        // upper 32 bit of the previous seed generated
        // to the previous number.
        for (int i = 0; i < (1 << 16); i++) {
            long candidateSeed = combine(arr[end], i);
            long previousSeed = getPreviousSeed(candidateSeed);

            if ((previousSeed >>> 16) == unsignedIntToLong(arr[end - 1])) {
                System.out.println("Testing seed: " +
                        previousSeed + " --> " + candidateSeed);

                for (int j = end - 1; j >= 0; j--) {
                    candidateSeed = previousSeed;
                    previousSeed = getPreviousSeed(candidateSeed);

                    if (j > 0 && (previousSeed >>> 16) == unsignedIntToLong(arr[j - 1])) {
                        System.out.println("Verifying: " + previousSeed + " --> " + candidateSeed);
                    }
                    else if (j == 0) {
                        // The XOR is done when the seed is set, need to reverse it
                        System.out.println("Seed found: " + (previousSeed ^ MULTIPLIER));
                        return previousSeed ^ MULTIPLIER;
                    }
                    else {
                        System.out.println("Failed");
                        break;
                    }
                }
            }
        }

        return null;
    }

    private static long MULTIPLIER = 0x5DEECE66DL;

    // Credit to James Roper
    // http://jazzy.id.au/default/2010/09/21/cracking_random_number_generators_part_2.html
    private static long getPreviousSeed(long currentSeed) {
        final long ADDEND = 0xBL;
        long seed = currentSeed;
        // reverse the addend from the seed
        seed -= ADDEND; // reverse the addend
        long result = 0;
        // iterate through the seeds bits
        for (int i = 0; i < 48; i++) {
            long mask = 1L << i;
            // find the next bit
            long bit = seed & mask;
            // add it to the result
            result |= bit;
            if (bit == mask) {
                // if the bit was 1, subtract its effects from the seed
                seed -= MULTIPLIER << i;
            }
        }

        return result & ((1L << 48) - 1);
    }
}